                   NBER WORICNG PAPER SERIES




                      ROSEPACK ])cuinent No. 3

           Guidelines for Writing Semi-portable FORTRAN

                         Neil E. Kaden*
                        Virginia K1ema'


                    Working Paper No. 130




Computer Research Center for Economics and Management Science
           National Bureau of Econanic Research, Inc.
                    575 Technology Square
                Cambridge, Massachusetts 02139


                        March 1976



NBER    rking papers are distributed informally and in limited
numbers for comments only. They should not be quoted without
written permission.
*NBERComputer Research Center. Research supported in part by
National Science Foundation Grant #DCR 75-08802 to the National
Bureau of Economic Research, Inc.
                            Abstract                                 1)

Transferring Fortran subroutines from one manufacturer' s machine
to another, or fran one operating system to another, puts certain
constraints on the construction of the Fortran statements that
are used in the subroutines. The reliable performance of rnathe-
matical software should be unaffected by the host environment in
which the software is used or by the compiler from which the code
is generated. In short, the reliable performance of the algorithm
is to be independent of the computing environment in which it is
run.
       The subroutines of ROSEPACK (Robust Statistics Estition
Package) are Fortran IV source code designed to be semi-portable
where semi-portable is defined to mean transportable with minimum
change. * This paper described the guidelines by which ROSEPACK
subroutines were written.


                       AcJciowledgements

The authors wish to thank J. Boyle and W. Cody for sharing their
internal document on prograimning conventions; J. Kirsch for his
helpful suggestions on documentation of subroutines, John Dennis,
Jim Ferris, David Gay Daiid Hoaglin and Gerald Ruderman for their
constructive criticism of this document, and Karen Glennon for her
careful typing of the manuscript.



*Cody, W.J., "The Construction of Numerical Subroutine Libraries,"
 SIAM Review, Vol. 16, No. 1, pp. 36-46, January (1974)
             Table of Contents




Inoduction                        1

PartOne                           2

PartTwo
References                       11

Appendix                         12
Introduction
Semi-portability of Fortran subroutines puts certain constraints on the
construction of Fortran statements, the declaration of variables, and the
representation of constants that are used in the subroutines. Many of
these constraints are needed for Fortran subroutines that are to be
imbedded in applications subsystems that are written in another language,
say FL/i.
       Frequently, the numerical algebra algoritl-nms themselves are strengthened
when their perforiince is unaffected by the arithmetic of the machine on
which they are used and the Fortran compiler by which their code is generated.
       The rules for structured programming [1,2,3] and structured documentation
(see Part Two, Section X of this document) should be followed insofar as
possible. The comments within the program or subroutine should be sufficient
to inform the user about input parameters, output parameters, temporary
storage parameters, error exits, and the algorithm that the program
implements. Sample programs are given in the Appendix.
       This document presents certain suggestions for programming that
will   tend   toward requirements   for   semi-portability of ANSI Fortran   IV

(as   described    in CACM, Vol. 7, No. 10, October '64) subroutines and

programs. We       also suggest certain conventions for comments and general
formatting    of   the Fortran code. By    "formatting" we mean the spacing

and   indentation that determine the general appearance and readability
of the code. Such formatting is suggested to help the reader or the user
understand the algorithm, the program, and the flow of control within
the program.
                                          —2—



Part One

Sane guidelines for programming are
    I.     CØMMØN storage should not be used for arrays.   This is not
           an ANSI restriction, but driver programs become simpler to
           write, and the use in a paged environment is erthanced if
           one does not use CØMMØN. CØMMØN storage requires a particular
           ordering   of   declarations so that boundary alignments conform.
           Arrays in CØMMØN must have fixed dimensions at compile time
           which may cause excessive storage allocation or a requirement
           to recompile if a user needs arrays of dimensions higher than
           those originally defined in the CØ1ØN block of storage.

    II.    All array arg.nnents should have adjustable dimensions. These
           dimensions should be made explicit in the declarations of the
           fonnal parameters for each subroutine. For example,

                       REAL A(NM,N)
           not
                       REAL A(NM,l)

           The latter construction may be rejected by some compilers.

   III.    EQUIVALENCE statements should not be used; EQUIVALENCE
           statements may inhibit automatic conversion between single
           and double precision.

    IV.    Certain Fortran compilers do not distinguish more than six
           characters of an identifier. Hold identifiers to six charac-
           ters or fewer.

     V.    Do not use multiple entry points or non-standard returns. Such
           constructions are not necessarily available for all compilers.
    VI.    Be sure that the precision of any Fortran library routine or
           built-in function is explicit in all statements. For example,
           DABS, not ABS, for absolute value for long precision computing.
           Do not use mixed mode arithnetic or assume there is an implied
           conversion anywhere, not even for constants. For example

                       DØUBLE PRECISION X
                       XX+       l0.ODO
           not
                       DØUBLE PRECISION X
                       X = X + 10.0
                                    —3—



 VII.   Constants that are used in iterations or convergence criteria
        should be functions of the machine' s precision, i. e., the
        smallest floating point number, , representable in  the   machine
        for which the floating representation of     1. Certainly, a
        constant that cannot be converted precisely on the machine
        should   never be used. For example, .1, is representative of
        such   numbers. N.unbers that can be representedexactly are
        integer powers of the base of the arithmetic of the canputing
        machine. Such numbers must be within the range of arithmetic
        of   the computing   machine.
VIII.   Test cases must be devised so that data can be converted uniformly
        on all target machine. The word length of the machine determines
        the truncation of the internal representation of floating point
        ni.unbers, and conversion routines do not treat floating point
        numbers uniformly. The integers are treated uniformly with respect
        to conversion so long as they lie within the precision range of
        arithmetic of the caiuting machine. One suggestion for portability
        for test cases used as input numbers is to read them in as integers
        and then DEFLAT to get the internal floating point representations.
        It is extremely inportant that the internal representation of data
        for test cases represent the same numbers on all target machines.
        Different internal representations can create perturbations (on
        input data) sufficient to cause changes in computed solutions that
        are awkward to analyze.
  IX.   Obscure underfiows can often produce side effects that give
        divide checks or overflows. This problem is particularly acute
        because the range of arithmetic on many machines is not symmetric
        about zero. For example2 the range of arithmetic on the IBM 360/
        370 machines   is about l0" >x> l0-°.     On the
        IBM360/370 mabhines, the number l0 is within the tolerated
        rangeof arithmetic; the reciprocal of 10 '' is not within the
        machine' s range of arithmetic. That an algorithm will exhibit
        overflow, underf low, or divide check problems is often not known
        in advance; moreover, some linear systems routines have this
        problem when an inner product is formed or when multiple multiplies
        are encountered. Be prepared to isolate such problems. Different
        opera.ting systems and different computing machines do not treat
        underflow interrupts uniformly. The variations in underfiow
        processing range fran ignoring the underf low completely to causing
        a termination fran the operating system. One solution to avoid
        underf low is to reorder arthmetic expressions. Another solution
        is to resort to extended precision arithmetic for critical
        sections of code.
   X.   The usual rules for separate sections for error handling and
        input-output that are required for applications subsystems
        are equally applicable for semi-portable FortTan programs.
        For convenience, the error handling fran the subroutines should
        be uniform. The input-output should be confined to main programs
        or special 1-0 subroutines; that is to say, computation
                                    —4—




           subroutines must be 1-0 fred. The goal of the error               TI)
           recovery is to permit canputation to continue without
           resorting to system termination, yet give the user
           information about the perfonnce of the algorithm on
           his problem. See the example of IERR in the QRF sub-
           routine in the Append.
   XI.     We expect the subroutines in ROSEPACK to be compiled
           with Fortran canpilers with the highest level of optimi-
           zation. We have not used hand optimization in the sub-
           routines. That we do not use hand optimization is a matter
           of style that we believe enhances the exposition of the
           algorithm. The indirection of addressing in QRF  is an
           example of such exposition.


Part Two

The suggestions for formatting are
     I.    Identifiers
           Identifiers, i. e., variable names, should correspond to
           default declarations in Fortran. However, explicit declara-
           tions should be written for each identifier.
           Variables from the calling sequence, internal variables, and
           function names should all be declared separately. For a
           suggestion on how to accanplish this see X Internal Documen-
           tation Section B (PARAMETERS), Section C (LOCAL VARIABLES),
           and Section D (FUNCTIONS) of the description of the Prologue.

    II.    Labels
           If the order of labels within a subroutine is not linear the
           convention used should be explicitly described. This order-
           ing of statement labels should be linear and could proceed
           in multiples of 10 for interior program sections. The next
           level of program section could proceed as 100, and perhaps
           the next as 1000.
           Do not  use unreferenced labels. Warning messages are given
           by   sane canpilers for unreferenced labels.
           Code for error exits should be surrounded by comments and
           located at the end of the program or subroutine so that error
           exits are easy to find. The labels for error  exists should
           be 2 or 3 digits, the first of which is 9, the last non-zero.
           The convention for labels is arbitrary.
           One format statement may be used by more than one print state-
           ment in a program. Therefore we suggest that all format state-
           ments be labeled with 4 digit numbers the last of which is non-
           zero andplaced after the RETURN statement and before the END
           statement of the program.
                                   —5—




       Preferably  all input-output should be written in subroutine
       form. We suggest that a DATA statement be used to fix units
       of 1-0 arid that this DATA statement be made particular to a
       given installation. An example of such a construction in a
       driver program could be
                   DATA lOIN /5/
                   DATA IOOUT /6/
       The variables containing this 1-0 unit information should be
       passed as parameters to all subroutines using these 1-0 units.
       This device allows a global change of an 1-0 unit without
       recompiling individual subroutines.
III.   Use of blank spaces
       There should not be extra blank spaces around dummy variables
       or constants D0 loops. Blank spaces should delimit symbols
       in assignment statements. This use of blank spaces avoids
       confusion between the use of = for assignment and for indexing.
       Blank spaces should be used wherever such use will erthance
       readability of elements of expressions or statements.
 IV.   Tab Spacings
       T1oughout this document we are assuming tab setting in columns
       1, 7, 10, 15, 20, 25, etc. The tab spacing is a matter of
       style and convenienáe   in reading.

  V.   Continuation Characters
       Second and subsequent lines of all continuation statements should
       be numbered 1 through 9, then A through Z in column 6. The text
       of each continuation statement should be indented one tab space
       from the initial line of the statement. The convention for
       continuation characters and tab spacing is inposed for consistent
       style.
 IV.   DO loops
       AU DO loops should be surrounded by comment statements which
       may be blank. Text comments should follow a blank comment state-
       ment. If more than one statement is in the range of a DO loop,
       the    closing statement of the DO loop should be a CONTINUE. This
       CONTINUE should be unambiguous. Statements between DO and
       CONTINUE should be indented one additional tab space to correspond
       to a      structure.
              block
       Inner loops should be indented one tab space to the right of their
       surrounding outer loop.
       For    examples of indentation of DO   loops   see the examples   in
       the   Appendix.
                                     -6—



 VII.   DATA Statements
        Data statements  should be used to set installation-dependent
        constants, such as data-set numbers for I/O, and machine preci-
        sion, uriderflow tolerances, or other machine-dependent constants.
        See X, Internal Documentation, Section L, for more details.
        If a non-numeric character string must be used in a DATA state-
        merit,it should be packed as one character per machine word
        and always stored in an array since different machines allow
        a varying number of characters to be stored in one machine
        word.

VIII.   Structured prograrruning
        The programming and formatting conventions that we describe
        are similar to structured progranuning in the following ways:
        1. format is for readability and understanding
        2.   indentation is done for major and minor loops
        3. array dimensions are adjustable
        Li.. temporary storage arrays are passed as parameters
        5. documentation is structured such that it is contained
             within the routine.
  IX.   Printed output                                                       I:)
        In order to aid in reproduction of the output, all    printed
        output should be formatted such that it is not greater than
        8 1/2 inches in width. Most line printers print 10 characters
        per inch, and 80 characters per line allows ample margins.
   X.   Internal Documentation
        All  Fortran programs should be well documented by liberal use
        of comment statements. Proper documentation will enhance read-
        ability and appearance of the code, improve understanding of the
        algorithm used, help ensure proper use of the program, and aid
        in future modifications. When semi-portability is also considered,
        proper documentation serves to isolate those portions of the code
        which are installation-dependent.
        In-line documentation of Fortran programs in ROSEPACK has been
        considered in two rnaj or sections, the Prologue and the Program—
        f low ccmnents. The latter consists of the crment statements
        embedded within the code describing how the algorithm is being
        carried out as the flow of control passes from statement to
        statement. The former consists of certain non-executable
        Fortran   statements   found at the beginning of the subprogram
        which fully describe the proper use of the software, as well
        as information concerning its development. Any user familiar
        with the guidelines has the added advantage of knowing where to
        find specific information concerning the program. The Prologue
        also identifies and isolates installation-dependent aspects of
        the program and thus enhances semi-portability. The Prologue
        is the maj or documentation for the use of the program or sub-
        routine.
                         —7—




The Prologue consists of the declarations of the calling
sequence arid variable names of the subprogram, a number of
sections of text on the subprogram, arid any DATA statements.
It contains a number of headings denoting the different
logical sections of the Prologue. The headings are comment
statements with the character "i" in columns 7 through 11
and the heading name beginning in solumn 12 and followed
by a colon (:). A blank caiiment statement should not
i.nimediately follow a heading. If the section denoted by
the heading line is empty, the heading should be followed
by a camnent statement containing "NONE'T in columns 7
through 10 and then a blank corrment statement.
The different headings, in the order they should appear, are:
          —PARAMETERS
          -LOCAL VARIABLES
          -FUNCTIONS
          -PURPOSE
          -PARAMETER DESCRIPTION
          -APPLICATION AND USAGE RESTRICTIONS
          -ALGORITHM NOTES
          —REFERENCES
          -HISTORY
          -GENERAL
          -BODY OF PROGRAM
Six delimiter lines, consisting of two blank coirment statements,
two comment statements consisting of the special character colon
(:) in columns 7 through 72, and then two more blank comment
statements, should occur immediately before the PURPOSE heading
and immediately after the GENERAL section. All lines between
these delimiters should be comment statements. when columns
73 through 80 of each line contain serialization of identifica-
tion characters, this gives a box-like appearance to the part
of the Prologue containing text.
An example of two programs following these guidelines is in
the Appendix.
What follows is a brief desiption of each section of the
Prologue. Note that no blank camnent statements should occur
until after the FUNCTIONS section.
     A. CALLING SEQUENCE
         The SUBRØUTINE or FUNCTIØN statement should be the
         first line of the subprogram. Blanks should be used
         to enhance readability.
     B. PARAMETERS
         Declaration statements should be grouped by type, i.e.,
         first INTEGER, then REAL, then DØUBLE PRECISION, or REAL*8,
                       —8—



     then REAL"l6, then CØNPLEX, CØMPLEX3 2   , then LØGICAL.
     Within each type grouping, variable names should be
     listed in the order they occur in the calling sequence.
     By parameters, we mean all of the variable names appear-
     ing in the calling sequence.
C. LOCAL VARIABLES
     As with the preceding section, declaration statements are
     grouped by type, and in the same order. Within each type,
     variable names should be listed alphabetically.
     ALL variables used in the program should be explicitly
     declared.
D. FUNCTIONS
     All functionscalled by the program should be explicitly
     declared. Declaration statements are grouped by type.
E. PURPOSE
     Briefly describe the purpose of this subprogram. Give
     references when necessary. More detail can be given
     in later sections.
F. PARA1'I       DESCRIPTION
     This section contains 3 subsections. The first describes
     input karameters, the second describes output parameters,
     and the third subsection describes parameters used for
     temporary storage by the subprogram.    Ifthe contents of
     any parameter variable can be changed by the subprogram,
     it should be considered an output parameter. See the
     examples   in
                 the Appendix for the foniiat, keywords, punctua-
     tion and indentation used in this section.
G.   APPLICATION AND USAGE RESTRICTIONS
     If any other programs in this package can call this
     subprogram,  or arecalled by it, they should be
     described  here. If this subprogram is part of a
     group of programs which are called in some specified
     order, this should also be included. Give references
     except when a reference is implicit, as with another
     member of the same package.
     Also included in this section are any warnings about            a
     special cases or possible errors which can occur if
     there are errors in the subprogram call. Warnings
     about misuse of tolerance parameters belong here.
     The entry in PARAI'ETER DESCRIPTION should refer the
     reader   to this section where applicable.
H. ALGORITIIII NOThS
     Anything special about the algorithm used or its imple-
     mentation should be listed here. Any special conventions
     regarding statement labeling or coninenting should be
                                                                    9
     mentioned. If there is anything special about error
     handling which has not yet been mentioned, it should be
     described here.
                           —9—




    I. REFERENCES
        References from elsewhere in the documentation, as well
        as any other references pertaining to the subprogram,
         should be   listed.
    J. HISTORY
        The author of this subprogram, we well as the date and
        place of origin should be listed. If the subprogram is
        a translation of a program in another language or is
        based on another program, a reference should be given.
        If the program has been modified since it was written,
        the date and person making the modification whould be
        noted. If this subprogram has been released as part of
        a subroutine library, the current release data of the
        library, and machine version, should be given.
    K. Gfl1ERAL
        If this subprogram was developed under research supported
        by a grant requiring adaowledgement, the required informa-
        tion should occur here. The person to contact concerning
        comments and problems with the subprogram should have his
        address in this section.
    L. DATA Statements
        Following the second occurrence of delimiting conTnent
        statements (two blank comment statements, two comment state-
        ments with colons in coliurins 7 through 72, and two more
        blank comment statements) is where all DATA statements
        should occur. If a DATA statement contains an
        installation-dependent constant, comment statements explain-
         ing its value and mentioning the inal' s designation,
         should precede the DATA statement. Those comment statements
         should conform to the standards of program-flow caiments.
    11. BODY OF PROGRAM
          This heading denotes the end of the Prologue and the
          beginning of the program body.
ogram-f low comments should be delimited by special characters to
enhance their readability and appearance. In ROSEPACI( the colon (:)
is used. Such comments should also follow the rules for statement
indentation described elsewhere in this document.
In most cases, the text of the comment should be preceded and
followed by a s'ing of 10 special characters (colons). At least
one blank space, but not more than three blank spaces, should be
put between the special character strings and the text of the
comment. If this method is used for a comment extending over
several lines, all lines whould have a "C" in colnn 1, and all
but the first line should be indented one additional tab (beyond
the current level of indentation).
                          -10—




Building   on the suggestions of Boyle arid Cody, an alternative
method of delimiting comments, recommended for imporrtant cormients
or those extending over several lines, is to surround them by
a "box" of special characters. The following is an example of
what is meant by a uboxIt:
C
c           ::


Blank comment statements (1. e., conunent statements containing
blanks in columns 2 through 72) may be used wherever their use
enhances the readability of the program.
The statement inunediately before the END statement should always
be a comment statement delimiting the end of the program and con-
taining the name of the program. The consistent wording can help
in separating several subroutines in one file. An example follows:

c           :::::::::::      LAST CARD OF (NAIvIE OF SUBROUTINE) :::::::::::
            END




                                                                               D
                                   -U-


                                References

[1]   Dahl, O.H, Dijksta, E.W., Iloare, C.A.R., S'uctured Parrirning,
      Academic Press, (1972).

£2]   Kerningharn, B .W., Plauger, P. J., "Prograimiirig Style: Examples
      and Counter-Examples," ACM Canputing Surveys, Vol. 6, No. ,
      pp. 303—319, December,   (197'4)


[3]   Kerninghan, B .W., Plauger, P .J., "The Elements of Programming Style,"
      Bell Telephone Laboratories (197 )
                                 -12-


                               Appendix                                  J
                                                                         Th

This appendix contains listings of two sUbroutines that are samples of
candidates for inclusion in ROSEPACK. The reader is reminded that we
are relying on Fortran compiler optimization of sub-expressions within
loops.




                                                                         3




                                                                         3
                                                             —13—




    SUBROUTINE
C   *****FARAMETERS:
    INTEGER NM,MuNcIPIVOT(N) ,IERR,IHTTC(N)
    REAL*8 OR(NM,N),ALPHA(N),Y(N),SUM(N)
C   *****LOCAL VARIABLES:
    INTEGER                 IJ,JBARK,K1MINUM
    REAL*8
C   *****FUNCTIONS:
    INTEGER MINO
    REAL*8 DABS,DSORT
C
C
    .   . . • +   •   e ,   •   • • • . • • • • • . • I   II4•   +   I• I I4•   I   •   4   4II•   • I   IIII$IIIIIIIIIIIII4III

C
C
C   *****PURPOSE:
C
C   THIS SUBROUTINE DOES A OR—DECOMPOSITION ON THE M X N MATRIX OR,
C      WITH AN OPTIONALLY MODIFIED COLUMN F'IVOTING, AND RETURNS THE
C      UPFER TRIANGULAR R—MATRIX AS WELL AS THE ORTHOGONAL VECTORS
C      USED IN THE TRANSFORMATIONS,
C
C   *****PARAMETER DESCRIPTION:
C   ON INPUT:
C
C          NM MUST BE SET TO THE ROW DIMENSION OF THE TWO DIMENSIONAL
C               ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
C                           DIMENSION STATEMENT
C
C          M MUST BE SET TO THE NUMBER OF ROWS IN THE MATRIX
C
C          N MUST BE SET TO THE NUMBER OF COLUMNS IN THE MATRIX
C
C          OR CONTAINS THE REAL RECTANGULAR MATRIX TO BE DECOMPOSEtI
C
C          IHTTC IS USED TO CONTROL PIVOTING. IF IHTTC(J) IS SET TO
C               ZERO FOR ALL J THEN NORMAL COLUMN PIVOTING IS USED.
C               IF IHTTC(J) IS LESS THAN 0 THEN THE J—TH COLUMN OF THE
C               INPUT MATRIX CANNOT BE IN THE FIRST N COLUMNS OF THE
C               OR—DECOMPOSITION, ALL ELEMENTS OF THIS VECTOR SHOULD
C               BE SET TO ZERO TO INSURE NORMAL PIVOTING
C
C          Y IS USED FOR TEMPORARY STORAGE FOR THE SUBROUTINE
C
C          SUM IS USED FOR TEMPORARY STORAGE FOR THE SUBROUTINE.
C
C   ON OUTPUT
C
C          OR CONTAINS THE NON—DIAGONAL ELEMENTS OF THE R—MATRIX
C                           IN THE STRICT UPPER TRIANGLE. THE VECTORS U WHERE
                                  —1k—


 C                Q—TRANSPOSE = IDENT — BETA * U* U—TRANSPOSE,
 C                ARE IN THE COLUMNS OF THE LOWER TRIANGLE 9
 c
 C           ALPHA CONTAINS THE DIAGONAL ELEMENTS OF THE R—MATRIX
 C
             IPIVOT REFLECTS THE COLUMN PIVOTING PERFORMED ON THE INPUT
 C                MATRIX TO ACCOMPLISH THE DECOMPOSITION. THE J—TH
 C                ELEMENT OF IPIVOT GIVES THE COLUMN OF THE ORIGINAL
 C                MATRIX WHICH WAS PIVOTED INTO THAT COLUMN DURING THE
 C                DECOMPOSITIONP
 C
 C           IERR IS SET TOt                                                     a
 C                0 FOR NORMAL RETURN,
 C                K IF NO NON—ZERO PIVOT COULD BE FOUND FOR THE K—7H
 C                     TRANSFORMATION,. OR
 C                —K FOR AN ERROR EXIT ON THE K—TH THANSFORMATION.
 C                IF AN ERROR EXIT WAS TAKEN, THE FIRST (K — 1)
 C                TRANSFORMATIONS ARE CORRECT.
 C
 C
 C        *****APPLICATIONS AND USAGE RESTRICTIONS:
 C        THE FORTRAN SUBROUTINE QRSOL SOLVES A SYSTEM AX—B BY USING
 C        QRF.                             .


 C
 C        *****ALGORITHM NOTES:
 C        THIS VERSION OF QRF TRIES TO ELIMINATE THE OCCURRENCE OF
 C        UNDERFLOWS DURING THE ACCUMULATION OF INNER PRODUCTS.
 C
 C        ADAPTED FROM THE ALGOL ROUTINE SOLVE (1).
 C                            .


 C        *****REFERENCES:
 C        Cl)     BU5INGER,P. AND GOLUB,G.H. LINEAR LEAST SQUARES
 C        SOLUTIONS BY HOUSHOLDER TRANSFORMATIONS, IN WILKINSONJ.H.
 C        AND REINSCHC.CEDS.)p HANDBOOK FOR AUTOMATIC COMPUTATION,
 C        VOLUME 11* LINEAR ALGEBRA, SPRINGER—VERLAG, 111—118 C1971fl
 C.   .   PREPUBLISHED IN NUMER.MATH. 7, 269—276 (1965),
 C
• C       *****HISTORY
 C        ROSEPACK RELEASE 0.2     FEBRUARY 1976
 C        IBM 360/370 VERSION
 C        DOUBLE PRECISION DECK
 C
          WRITTEN BY NEIL E. KADEN CNBER/CRC) 1974
 C        MODIFIED 20 APRIL, 1975 BY N. KADEN
 C
 C        *****GENERAL:
 C        QUESTIONS AND COMMENTS SHOULD BE DIRECTED TOt
 C           SUPPORT STAFF MANAGER
 C           COMPUTER RESEARCH CENTER FOR ECONOMICS AND MANAGEMENT SCIENCE


                                                                             j
 C           NATIONAL BUREAU OF ECONOMIC RESEARCH
 C           575 TECHNOLOGY SQUARE
 C           CAMBRIDGE, MASS. 02139.           •
                                                       —15--




C
C           DEVELOPMENT OF THIS PROGRAM SUPP) ED IN PART BY
C           NATIONAL SCIENCE FOUNDATION GRANT GJ—1154X3 ANtI
C           NATIONAL SCIENCE FOUNDATION GRANT DCR75—08802
C           TO NATIONAL BUREAU OF ECONOMIC RESEARCHY INC.
C
C
C

            •,,,,,,.,,,,,•,.,,,,,,,,,..,,,,,,+,,••+,,,,,.,,,.,,,•,,•,+,,••,•,
            ,,,,,.,•,,,,,,,,,,,,,+..,,,,,+,,,,,,,,,•.,•,,+,,,,••,•,,,,,•,+,,,
C
C
C           :::::::::: UFETA IS THE SMALLEST POSITIVE FLOATING POINT NUMBER
C              9.1. UFETA AND —UFETA CAN BOTH BE REPRESENTED,
C              IBM 360/370: UFETA = 16.**—65 ::::::::::
            DATA UFETA /Z0010000000000000/
C
            UFTOL = E'S(RT(UFETA)
C
C           *****BOLIY OF PROGRAM:
            IERR = 0
C
            DO 40 J=1N
I..,           • • • • • + • + • + ..Ji   -ru   r'niii.i
                                           11 L,UI...JI        tIM'••••''•s'
                                                        uI'C Lfl I+ ••+ • + • +
               QRKMAX = 0.ODO
C
               DO 10 I=1,M
                         IF (t'ABS( OR(I,J) )                   .61,    ORKMAX) ORKMAX = DABS( QR(IJ)
       10      CONTINUE
C
               SUM(J) =          0.0tio
               IF (QRKMAX •LT. UFTOL) GO TO 30
C
               rio   20 I=1'M
                         IF      DABS         OR(I,J) ) .LE. QRKMAX * UFTOL) GO TO 20
                         TEMP   OR(IJ) / ORKMAX
                         SUM(J) = SUM(J) + TEMP * TEMP
       20      CONTINUE
C
               SUM(J) = ORKMAX * QRKMAX * SUM(J)
       30      CONTINUE
             IPIVOT(J) = J
       40 CONTINUE
C
            MINUM = MINO(M,N)
C
            ['0 200 K=1,MINUM
               ,,.,,,,,,,tuI1
                • • I.. • • • +i. ru urIItr'rLJrI rlr.
               SIGMA = 0.OtIO
                                              F1UJL.I1UI...LL...F\
                                                                       AKt1I.Arrr.I..I, • . • , , • +
                                                                     ur\Ju,rur\uurIlJ.L,uN,..+..s...
               JBAR = 0
               •
                                                   r'nhii.i II4++••++•+•+
                                        IAt.r'tcr.ULlJuII'C
                   • • •i+•+ +1J.I'U. I_rIu\us.,u           ..JII, + • • + • + • •     +

               DO 110 J=KN
                         IF (IHTTC( IPIVOT(J) ) •LT. 0) 60 TO 110
                                     —16—



                   IF (SIGMA •GE. SUM(J)) GO TO 110
                   SIGMA — SUM(J)
                   JBAR=J
     110      CONTINUE
C
              IF (JBAR .EO, 0) GO TO 999
              IF (JBAR •EQ. K) GO TO 130
C             :::n:::UC0LUMN INTERCHANGES:t:tuu:
              I • IPIVOT(K)
              IPIVOT(K)    IPIVOT(JBAR)
              IPIVOT(JBAR) •
              SUM(JBAR) — SUM(K)
                                 I                                             a
              SUM(K)    SIGMA
C
              DO 120 I=1,M
                   SIGMA — QRCI,K)
                   QR(I,K) • GR(I,JBAR)
                   UR(I,JBAR) • SIGMA
    120       CONTINUE
C             ::::WWEND OF COLUMN INTERCHANGE:n:::n::
    130       CONTINUE
C             *tu:uu: SECOND INNER PRODUCT ::nn:ns
              QRKMAX     0.ODO
C
              DO 140 IK,M
                   IF CDABS( QR(I,K) ) •GT. QRKMAX) ORKMAX — DABS( QR(IpK) )
    140       CONTINUE
C
              SIGMA • 0.ODO
              IF (QRKMAX •LT. UFTOL) GO TO 998
C
              DO 150 I—K,M
                   IF CDABS( OR(I,K) ) •LE. QRKMAX * UFTOL) GO TO 150
                   TEMP • OR(I,K) / ORKMAX
                   SIGMA — SIGMA + TEMP * TEMP
        150    CONTINUE
C
              SIGMA = QRKMAX * QRKMAX * SIGMA
C             sun::::: END SECOND INNER PRODUCT ::::u::::
              IF (SIGMA .EQ. 0.ODO) GO TO 998
              GRKK = QR(KaK)
              ALPHAK = DSQRTCSIGMA)
              IF (QRKK •GE. 0.ODO) ALPHAK = —ALPHAK
              ALPHA(K) = ALPHAK
              BETA = 1.ODO / (SIGMA — ORKK*ALPHAK)
              QRCKrK)    ORKK — ALPHAK
              K1 = K + 1
              IF CK1 •GT. N) GO TO 200
C
              DO 170 JK1,N
    •             TEMP = 0.ODO
C
                  DO 160 I=K,M
                       TEMP = TEMP + QR(I,K)*QR(I,J)
                                                               —17—



       160                   CONTINuE
C
                       Y(J) = BETA * TEMP
       170        CONTINUE
C
C
                  110       190 J=K1,N
C
                              DO 180             I=KM
                                           OR(I,J) = OR(IJ) —                      QR(I,K)*Y(J)
       180                    CONTINUE
C
                        SUM(J) = SUM(J) — OR(K,J)**2
       190    CONTINUE                                                                                    MA r rn LI• • • • •
              , , . . . . , . • • Lu'IL
              , . , . • • , • , • rr i..i rLII     ii u nil cr- LI r. i r rr. T e. AKI c
                                            r k•i' I ri flUULF1UL. L1 I irIir                          JII II I .LUI + • $ +
                                                                                                      rr .                       •• •' •• •• •
       200 CONTINUE
C
             GO TO 1000
C
I..,
              4 • I I   •••+   • • -   i. r.       L.A.LI    ji i\     r
                                                                       U r 1. A LI r i, r:. MAT r ri LII I • • I I I
                                               r I, E V r r fi KI I — Irl                                              •   I I


       998 IERR = —K
           GO TO 1000
C
U             • I • +   I
                     I • • • I
              +•I+4+++++IW        Kt
                                  Kinki
                             I!.JI'( L.C.PU ruUUI.I 111D1...L                                   fJUI'L+++I$,$I4+I
                                                               Ai'r'C?r,TAr,i r C. TI iT CI ikir I • • • • • • • I
                                                                                    U.LVLII
       999 IERRK
C
              ++.,I,,,+,r,rTIIC.KI
                                 IUrn AIIIC,+II++4I++I
                                    UIL..LL.F\+++++I+++
U
       1000 RETURN
U             ••++44++III   AT UIlr\L.
              ,,,,,,,,,,L_rII   I—AC.r UI
                                       nc t..'CF%I
                                          nr.c.,I+,+$III
                                                   •,,,..$I+$
              END
                                              —18—



    SUBROUTINE WANDRW C N, U, CONST,SQW)
C   *****PARAMETER5:
    INTEGER N                           -
    REAL*S UCN),CONST,SQW(N)
C   *****LOCAL VARIABLES:
    INTEGER I
    REAL*S C1POFLIPI,PI,RKTOL,UFETA,UpLIM,Us
C   *****FUNCTIONS:                      -

    REAL*S DAB5,DSIN,DSQRr
C
C
c   : : : : : : : : : : : : : : : : : : : : : :: : : : : : : : : : : : :: : : ::::::::: : : : : : : : : : : : : :
                                                                                                                              a
                                                                                                                  : : : : :
c   :::::::::::::::::::::::::::::::::::::::::::::::::: :::::::::::::
C
C
C   *****PURpOSE:
C   THIS SUBROUTINE PRODUCES THE SQUARE ROOTS OF THE WEIGHTS
C   DETERMINED BY THE INPUT VECTOR U OF PREVIOUSLY COMPUTED
C   SCALED RESIDUALS AND THE ANDREWS WEIGHT FUNCTION. (REFERENCE 1)
C
C   *****PARAMETER DESCRIPTION:
C   ON INPUT:
C
C       N MUST BE SET TO THE NUMBER OF ELEMENTS IN THE VECTQRS U AND
C            SQW
C
C       U CONTAINS THE STANDARDIZED RESIDUALS FROM A PREVIOUS LINEAR
C            FIT. THAT IS, UCI) = RCI) /.S WHERE R(I) IS THE I—rH
C            RESIDUAL FROM A LINEAR FIT, RCI) = YCI) — YFITTED(I),
C            AND S — 5CR) IS A RESIDUAL SCALING FINCTION (E.G. S bOULD
C            BE THE OUTPUT OF THE FORTRAN SUBROUTINE SMAD).
C
C       CONST IS THE 'TUNING CONSTANT' FOR THE WEIGHT FUNCTION
C            WCU). IF CONST IS NOT POSITIVE, OR EXCEEDS UPLIM, AN
C            ERROR EXIT WILL BE TAKEN. (SEE APPLICATION AND USAGE
C            RESTRICTIONS)
C
C
C   ON OUTPUT:
C
C       CONST IS UNCHANGED IF NO ERROR EXIT OCCURRED.
C            IF CONST WAS LESS THAN OR EQUAL TO ZERO, THEN
C            CONST REMAINS UNCHANGED.
             IF CONST WAS GREATER THAN THE ALLOWABLE UPPER
C            LIMIT, THEN CONST IS SET TO MINUS ONE.
C
C
C       SQW CONTAINS A VECTOR OF THE SQUARE ROOTS OF THE WEIGHTS
C            DETERMINED BY THE SCALED RESIDUALS AND THE WEIGHTING
C            FUNCTION.
C
C   *****APPLICATION AND USAGE RESTRICTIONS:
                                           —19—




      C    THE ROc)T—WEIGHTs ARF: NEE:DEEt FOR •rI-!E
      C    Ti FIO 1$ Vi L ( bOWl LH IL D I rr StUA CO PL1TATIIflJ OF THE
                                                    rs Esi lh'- 11 5 L 13 THE
      C    FORTRAN SUEOI I NEs ti :i:w IT
           SUW (   I ) MULTIPLIES'rlft: CC)RF
                                                m
                                                MINSQI_ ,     ni :cs COPUTArI Oi
      C    ANti THE Y—•vFrToR
                                                OtJtI ROWE OF •nn:
                                   C PEIEr;FNrF " )                  x—iix
      C
      C    THE LARGER 1 HE VALUE OF-        CONT, IHE MORE NEARL.Y ALL THE VALuES
      C    OF (4(U) WILL EQUAL. UNITY
      C
      C    IF CONST IS TAKEN TO BE VERY SMALL IT IS POSSIBLE TO F'RODUCE A
      C:
           VECTO1: OF ROOT—WEIOFIrS ALL OF WHICH EQUAL OR NEARLY EQUAL
      C    ZErO, A'rt I H IS (4LLL 1,-iL U:LLEb AS fli UT 10 1HI WE:1IULLI
      C    SQUARES COMPUTATIONS.                                           LEA     ..T
      C
      C    IF A T1JNIN(3 CONSTANT VALUE OF 1.3:39 'IS UEED, UNDER
                                                                  THE
      C    ASSUIIPTIr)N OF oiissi ERRORS, THE RESULTIiG E:STIMATOR
      C    WILL HAVE 95 PERcE:NT ASYMPTOTIC
      C                                       EFFICIENCy
      C    IT IS POSSIBLE TO COMPUTE SQL' WHEN COMSI EXCEEDS
      C    IMPosEri ' BLUr AS THIS RECiU:ERES ADDITIONAL. TESTS   THE UPPER LIMIT
      C                , IT WILL BE IMPLEMENrF_r, WHEN Tills    FOP UN:CLERFLO!,js AND
                                                               CAPABILITY   IS
      C    JUIT)I ILL',
      C
      C    WARNING — AS AN ERROR EXIT MAY CAUSE THE VALUE OF CONST
      C    OVERWRITTEN, IF A CONSTANT (RATHER                           TO BE
      C                                            THAN A VARIABLE)  WAS
           THE CALLING FROGR'ALI, TI-lEN •rHE CALLER'S CONStANT TtILE MAY
                                                                         PASSED '
      C    BE CHANCED CAus:UNO INCURR[:CT BEHAVIOR OF THE PROciRAM
      C
           ***:AL.GIJRI'rE.ljl NOTE3:
      C    THE INPUT PARAMETERS ARE CHECKED TO
      C.   OVERFLOWS,                        .
                                               AVOID UNDERFLOLJS AND
                                                          .
           FOR. SUFFICIENTLY SMALL VALUES OF UCI) AN AFPRO)(I1ATIoN BY POWER
           SERIES EXPANSION IS USED.
      C
                                    .               .
      C    *****REFERENCES:                     .
      C    (1)      ANDREWS.YtI,F. (1974), TECHNOMETRICS 16, 523—532.
      C    (2)
I.   #C

      C
              147—192,
                       BEATON,.,E. AND IUKEY,j,w, (1974), TECHNO?IETRICS 16,

           *****HIST0RY:
U          ROSEPACI< REL.EASE O2           FEBRUARy 1976
      C    IBM 360/370 VERSION
      C    DOUBLE PRECISION DECK
     C
      C    WRITTEN BY NEIL NADEN (NBER / COMPUTER RESEARCH
     C     JUNE 23 1975,                                   CEr.!TER)
     C     tiOI:'IFIED 23 JULY, 1975 BY NEIL KADEi
     C     MOLlIFIED 29 OCTOBER, 1975 BY NEIl KABEN
     C
     C              EN ER AL
     C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO:
     C        SUPPORT STAF'F MANAGER
     C        COMPU'rER RESEARCH CENTER FOR ECONO1ICS AND MANAGEMENT SCIENCE
              NATIONAL BUREAU OF ECONOMIC RESEARCH
                                                                                   —20—




C                               Sn     TECHNOLOGY SQUARE
                                                                                                                                                                                                                                   1'
C                               CAMBRIDGE, fIASS. 02139.
C                                                                                                                                                                                         -

C                       DEVELOPMENT OF THI•S PROGRAM SUPPORTED IN PART BY
C                       PffiTIONAL SCIENCE FOUNDATION GRANT GJ—1154x3 AND
C                       NATIONAL SCIENCE FOUNDATION GRANT DCR75—09902
C                       TO NATIONAL BUREAU OF ECONOMIC RESEARCH, INC.:
'C
C
C                          .,   I.                                                                                     • •....4•,..,.....                                                                                               a
C
C.
                           .',....,,..,...,.....I,..I4.......II....,
                           ..44444••4      4    4 4 * 4 4 4 .4 4 4 4 4 4 4 4 4 4 4 I I 4 4 4 4 4 4 I 4 4 I 4 4 4 4 4 4 • 4
                                                                                                                                                                                                      I 4 I 4 I 4 44 4 I I 4 4 4

C
•C
C
                           ::::::n::        •

                                       OFLIM IS THE LARGEST. POSITIVE FLOATING
                                                                               POINT NUMBER
                              IBM 370/360: OFLIM =                —                 C16.**63)*ci.                                                             16.fl—14)                                   h:unu;
                       DATA' OFLIM /Z7FFFFFFFFFFFFFFF/                                                                       .




                       :....,.,...
                        •*•s+b•e.. flY    atL—f,. •tte.•
                                     ra. "V
                   •   DATA P1 /3.1415926535a9791,o,.
C
C                      :::i:ujt:• R1CTOL IS THE SQUARE ROOT OF THE RELATIVE PRECISION
C                         OF FLOATING POINT ARITHMETIC CHACHEP).
C                      •
                         'IBM 360/370: RKTOL = 2.t*—26 44•4414444
                       DATA RKTOL /Z3A4000000000oooo/
C
C                          ;::nn::: UFETA IS THE SMALLEST' POSITIVE flOATING POINT NUMBER
C              •              S.T. LJFETA AND —UFETA CAN BOTH BE REPRESENTED.
C                             IBM 360/370: UFETA = 16.**—65 ::::::w:          :.
           •
                       DATA UFETA '/ZOOlOOOoooooooooo,                                                                                               ..
                                                                                                                                                                                           .
                                                                                                                                                                                                     t'
C..
C
                       UPLIM .= OFLIM/ P1
                       ..            '.:
                       *****BDDY OF PROGRAM:
                                                .


                                                                  ..
                                                                       •


                                                                                                 :. •,•' .:'. ''•..  .                                   .               a.
                                                                                                                                                                              '               .•


                                                                                                                                                     '' '..
                                                                                             .

               •
                       IF CCONST •LE, 0.ODO) RETURN
C •:                    ::::::u:i.                                          •..• 'i'
                                    ERROR EXIT F CONST IS NOT POSITIVE :tuuu::
                       IF (CONST .LE; UPLIM) GO TO.10.
                                                                                                                         .




                                                             •
C
                                                                                                                         .


                       :n::::::tERROR EXIT IF CONST   IS
                                                       • TOO   LARGE.. ::::::u::
                       CDNST = —1.0130           .                                                                                                                                                                                 4,
                                           .
                                             .
                                                    .
                                                           .
                                                                         .  ...... .. .                         ..
                        •,•••,••
                       RETURN
                                                 JflI a •snj
                                                                                         .

'p     •                ••..••••••                               ..
                                                flflktOT TO ai DAMne ••••••...                                       •
                                                                                                                                                                                                   .'....
       10 CONTINUE                                     .                                              .,•                        .
                                                                                                                                                 ..'          .
                                                                                                                                                                          •


                       Cl       = CONST * DSQRTC12.ODO')                                                .
                                                                                                                                                              .. ..
                                                               •
                       DO 100 I=1,N                •
                                                     . .
                                                                                                 ..                                          ••                     :•
                                                                                                                                                                                      •

                                Ui = DABS( WI) )                 . . .                                                                   .


                                IF CU1 •LE. P1 * CONST) 60 TO 20
                                :::::::::: DABSC UCD ) .GT. P1 * CONST :'::u:::::
                                50(4(I) = 0.ODO                                                                                                                                   .           .
                                                                           .            ..                  .
                                                                                                                ..                   :       .                •.•
                                GOTO100                                                                                                                  ...'
       20                       CONTINUE                                            .                           .                                .
                                                                                                                                                          .

                                IF    (Ui .GE. UFETA*C1) GO TO 30
                                :::::::::.:     DIVISION WOULDUNDERFLOW
                                                                 .
                                                                                                                                                               .



                                                                                                                                                                         fl:n::::
                                50(4(I) =   'l.ODO    .
                                                          . .                                                                                                             .
                                                              .
                                                                                                                                                              .•
                                                                   .


                                GOTOIOO                                        .                                                                     •
                                                                                                                                                                              -
                                   -21-




     30     CONTINUE
            Ui = U(I) / Cl
C           ''''        CHECK  IF Ui IS IN RANGE  ,,..,,,,,,
                                                         ''
            IF     W
               (DABS(  Ui ) .01.  RKTOL) GO TO 40
C'          4,4,,,,,,.  USE  ALTERNATE METHOD FOR SMALL VALUES
            SOW(I) = (0.5Db + Ui + 0.5110) * (0,500 — Ui + 0.5110)
            GO TO 100
      40    CONTINUE
C
            '''''' FUNCTION CAN BE COMPUTED NORMALLY                 4

            Ui = U(I) / CONST
            SObJ(I) = IISORT( DSIN(U1) / Ui )
     100 CONTINUE
C
          RETURN
C
          ''''''''                        ••4••4•4•4
                     LAST CARD OF WANDR.. ..........
                                          1.1



          END
